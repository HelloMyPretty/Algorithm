import java.nio.channels.ScatteringByteChannel;
import java.util.ArrayList;
import java.util.PriorityQueue;

import javax.xml.xpath.XPath;

public class Dijkstra {
	static int maxn=10000;
	static class Edge{			//存储边的信息
		int from,to,dist;
		public Edge(int x,int y,int z) {
			from=x;
			to=y;
			dist=z;
		}
	}
	
	static class Node implements Comparable<Node>{		//结点信息
		int dis,id;			//dis是源点到顶点id的距离
		public Node(int x,int t) {
			dis=x;
			id=t;
		}
		@Override
			public int compareTo(Node o) {
				return Integer.compare(dis, o.dis);
			}
	}
	
	 int n,m;											//n是顶点数目，m是边数目
	 ArrayList<Edge> edges=new ArrayList<>();			//输入的边的信息列表
	 ArrayList<Integer>[] gra=new ArrayList[maxn];		//邻接表
	 int[] dis=new int[maxn];								//记录源点到每个点的距离 
	 int[] p=new int[maxn];								//记录最短路中的上一条弧，用于寻找路径。
	
	 void init(int nn) {								//初始化
		n=nn;
		for(int i=0;i<n;i++) {
			gra[i].clear();
			dis[i]=Integer.MAX_VALUE;					//将d[]全部初始化为最大值
		}
		edges.clear();
	}
	
	void addEdge(int form,int to,int w) {
		edges.add(new Edge(form, to, w));
		gra[form].add(edges.size()-1);
	}
	
	void dijkstra(int s) {
		dis[s]=0;
		PriorityQueue<Node> queue=new PriorityQueue<>();
		queue.add(new Node(0,s));				//源点入队
		while(!queue.isEmpty()) {
			Node cur=queue.poll();
			int id=cur.id;
			if(cur.dis!=dis[id]) 					//该节点已经完成更新，
												//某个结点只用被取出一次，就能更新彻底
				continue;
			
			//松弛操作,更新结点cur的邻接点距离 源点的距离
			for(int i=0;i<gra[id].size();i++) {		
				Edge e=edges.get(gra[cur.id].get(i));
				if(dis[e.to]>dis[id]+e.dist) {		
					dis[e.to]=dis[id]+e.dist;
					p[e.to]=gra[id].get(i);				//记录父节点
				}
			}
		}
	}	
}
