import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Scanner;


public class Dijkstra {
	static int maxn=10000;
	static class Edge{			//存储边的信息
		int from,to,dist;
		public Edge(int x,int y,int z) {
			from=x;
			to=y;
			dist=z;
		}
	}
	
	static class Node implements Comparable<Node>{		//结点信息
		int dis,id;			//dis是源点到顶点id的距离
		public Node(int x,int t) {
			dis=x;
			id=t;
		}
		@Override
			public int compareTo(Node o) {
				return Integer.compare(dis, o.dis);
			}
	}
	
	 int n,m;											//n是顶点数目，m是边数目
	 ArrayList<Edge> edges=new ArrayList<>();			//输入的边的信息列表
	 ArrayList<Integer>[] gra=new ArrayList[maxn];		//邻接表
	 int[] dis=new int[maxn];								//记录源点到每个点的距离 
	 int[] p=new int[maxn];								//记录最短路中的上一条弧，用于寻找路径。
	
	 void init() {										//初始化
		edges=new ArrayList<>();
		 for(int i=1;i<=n;i++) {						//顶点编号从1到n
			gra[i]=new ArrayList<>();
			dis[i]=Integer.MAX_VALUE;					//将d[]全部初始化为最大值
		}
		edges.clear();
	}
	
	void addEdge(int form,int to,int w) {
		edges.add(new Edge(form, to, w));
		gra[form].add(edges.size()-1);
	}
	
	void dijkstra(int s) {
		dis[s]=0;
		PriorityQueue<Node> queue=new PriorityQueue<>();
		queue.add(new Node(0,s));				//源点入队
		while(!queue.isEmpty()) {
			Node cur=queue.poll();
			int id=cur.id;
			if(cur.dis!=dis[id]) 					//该节点已经完成更新，
													//某个结点只用被取出一次，就能更新彻底
				continue;
			
			//松弛操作,更新结点cur的邻接点距离 源点的距离
			for(int i=0;i<gra[id].size();i++) {		
				Edge e=edges.get(gra[cur.id].get(i));
				if(dis[e.to]>dis[id]+e.dist) {		
					dis[e.to]=dis[id]+e.dist;
					p[e.to]=gra[id].get(i);						//记录父节点
					queue.add(new Node(dis[e.to], e.to));		//邻接点入队
				}
			}
		}
	}
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		Dijkstra test=new Dijkstra();
		test.m=cin.nextInt();
		test.n=cin.nextInt();
		test.init();
		for(int i=0;i<test.m;i++)
		{
			int u,v,w;
			u=cin.nextInt();
			v=cin.nextInt();
			w=cin.nextInt();
			test.addEdge(u, v, w);
		}
		test.dijkstra(1);
		System.out.println(test.dis[n]);
	}
}
